{"version":3,"file":"index.browser.js","sources":["../package.json","../src/index.ts"],"sourcesContent":["{\n  \"name\": \"@jspsych-contrib/plugin-maze\",\n  \"version\": \"0.0.1\",\n  \"description\": \"A jsPsych plugin for running Maze experiments\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"typings\": \"dist/index.d.ts\",\n  \"unpkg\": \"dist/index.browser.min.js\",\n  \"files\": [\n    \"src\",\n    \"dist\"\n  ],\n  \"source\": \"src/index.ts\",\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"npm test -- --watch\",\n    \"tsc\": \"tsc\",\n    \"build\": \"rollup --config\",\n    \"build:watch\": \"npm run build -- --watch\",\n    \"dev-serve\": \"concurrently \\\"npm run build -- --watch\\\" \\\"serve\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jspsych/jspsych-contrib.git\",\n    \"directory\": \"packages/plugin-maze\"\n  },\n  \"author\": {\n    \"name\": \"Morgan Grobol\",\n    \"url\": \"https://lgrobol.bzh\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jspsych/jspsych-contrib/issues\"\n  },\n  \"homepage\": \"https://github.com/jspsych/jspsych-contrib/tree/main/packages/plugin-maze\",\n  \"peerDependencies\": {\n    \"jspsych\": \">=8.0.0\"\n  },\n  \"devDependencies\": {\n    \"@jspsych/config\": \"^3.2.2\",\n    \"@jspsych/test-utils\": \"^1.0.0\",\n    \"concurrently\": \"^9.1.2\",\n    \"jspsych\": \"^8.0.0\",\n    \"serve\": \"^14.2.4\"\n  }\n}\n","import { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\n\nimport { version } from \"../package.json\";\n\nconst info = <const>{\n  name: \"maze\",\n  version: version,\n  parameters: {\n    /** Array of [word, foil] couples */\n    sentence: {\n      type: ParameterType.COMPLEX,\n      array: true,\n    },\n    canvas_border: {\n      type: ParameterType.STRING,\n      pretty_name: \"Canvas border\",\n      default: \"0px solid black\",\n    },\n    canvas_colour: {\n      type: ParameterType.STRING,\n      pretty_name: \"Canvas colour\",\n      default: \"white\",\n    },\n    canvas_size: {\n      type: ParameterType.INT,\n      array: true,\n      pretty_name: \"Canvas size\",\n      default: [1280, 960],\n    },\n    font_colour: {\n      type: ParameterType.STRING,\n      pretty_name: \"Font colour\",\n      default: \"black\",\n    },\n    font_family: {\n      type: ParameterType.STRING,\n      pretty_name: \"Font family\",\n      default: \"monospace\",\n    },\n    font_size: {\n      type: ParameterType.STRING,\n      pretty_name: \"Font size\",\n      default: \"24px\",\n    },\n    font_weight: {\n      type: ParameterType.STRING,\n      pretty_name: \"Font weight\",\n      default: \"normal\",\n    },\n    keys: {\n      type: ParameterType.COMPLEX,\n      pretty_name: \"Validation keys\",\n      default: { left: \"f\", right: \"j\" },\n      nested: {\n        left: {\n          type: ParameterType.STRING,\n          pretty_name: \"Left key\",\n        },\n        right: {\n          type: ParameterType.STRING,\n          pretty_name: \"Right key\",\n        },\n      },\n    },\n    position_left: {\n      type: ParameterType.COMPLEX,\n      pretty_name: \"Position of the left element.\",\n      default: { x: null, y: null },\n      nested: {\n        x: {\n          type: ParameterType.FLOAT,\n          pretty_name: \"Horizontal position\",\n        },\n      },\n      y: {\n        type: ParameterType.FLOAT,\n        pretty_name: \"Vertical position\",\n      },\n    },\n    position_right: {\n      type: ParameterType.COMPLEX,\n      pretty_name: \"Position of the right element \",\n      default: { x: null, y: null },\n      nested: {\n        x: {\n          type: ParameterType.FLOAT,\n          pretty_name: \"Horizontal position\",\n        },\n      },\n      y: {\n        type: ParameterType.FLOAT,\n        pretty_name: \"Vertical position\",\n      },\n    },\n    translate_origin: {\n      type: ParameterType.BOOL,\n      pretty_name: \"Translate origin\",\n      default: true,\n    },\n    /** How long to wait after showing a word and before registering keypresses (in ms) */\n    waiting_time: {\n      type: ParameterType.INT,\n      pretty_name: \"Waiting time\",\n      default: 0,\n    },\n  },\n  data: {\n    /** TODO: Provide a clear description of the data1 that could be used as documentation. We will eventually use these comments to automatically build documentation and produce metadata. */\n    report: {\n      type: ParameterType.COMPLEX,\n      array: true,\n      nested: {\n        correct: { type: ParameterType.BOOL },\n        foil: { type: ParameterType.STRING },\n        rt: { type: ParameterType.INT },\n        side: { type: ParameterType.STRING },\n        word: { type: ParameterType.STRING },\n        word_number: { type: ParameterType.INT },\n      },\n    },\n  },\n  // prettier-ignore\n  citations: '__CITATIONS__',\n};\n\ntype Info = typeof info;\n\nfunction set_canvas(\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  colour: string | CanvasGradient | CanvasPattern,\n  translate_origin: Boolean\n) {\n  let canvas_rect: number[];\n  if (translate_origin) {\n    ctx.translate(canvas.width / 2, canvas.height / 2); // make center (0, 0)\n    canvas_rect = [-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height];\n  } else {\n    canvas_rect = [0, 0, canvas.width, canvas.height];\n  }\n  ctx.fillStyle = colour;\n  ctx.fillRect(canvas_rect[0], canvas_rect[1], canvas_rect[2], canvas_rect[3]);\n  ctx.beginPath();\n  return canvas_rect;\n}\n\n/**\n * **maze**\n *\n * A jsPsych plugin for running Maze experiments\n *\n * @author Morgan Grobol\n * @see {@link https://github.com/jspsych/jspsych-contrib/packages/plugin-maze/README.md}}\n */\nclass MazePlugin implements JsPsychPlugin<Info> {\n  static info = info;\n\n  constructor(private jsPsych: JsPsych) {}\n\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\n    display_element.innerHTML = `<div>\n      <canvas\n        id=\"canvas\"\n        width=\"${trial.canvas_size[0]}\"\n        height=\"${trial.canvas_size[1]}\"\n        style=\"border:${trial.canvas_border};\"\n      ></canvas>\n      </div>`;\n\n    const sentence_font = `${trial.font_weight} ${trial.font_size} ${trial.font_family}`;\n\n    const canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n    const ctx = canvas.getContext(\"2d\");\n    const canvas_rect = set_canvas(canvas, ctx, trial.canvas_colour, trial.translate_origin);\n    const canvas_center = {\n      x: canvas_rect[0] + canvas_rect[2] / 2,\n      y: canvas_rect[1] + canvas_rect[3] / 2,\n    };\n\n    const position_left = {\n      x:\n        trial.position_left.x !== null\n          ? trial.position_left.x\n          : canvas_rect[0] + canvas_rect[2] / 3,\n      y: trial.position_left.y !== null ? trial.position_left.y : canvas_center.y,\n    };\n    const position_right = {\n      x:\n        trial.position_right.x !== null\n          ? trial.position_right.x\n          : canvas_rect[0] + (2 * canvas_rect[2]) / 3,\n      y: trial.position_right.y !== null ? trial.position_right.y : canvas_center.y,\n    };\n\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n\n    let word_on_the_left: Array<boolean>;\n    let word_number: number;\n    let last_display_time: number;\n\n    let trial_data = {\n      sentence: trial.sentence.map((x) => x[0]).join(\" \"),\n      events: [],\n    };\n\n    let keyboardListener: { (e: KeyboardEvent): void; (e: KeyboardEvent): void };\n\n    const clear_canvas = () => {\n      ctx.font = trial.canvas_colour;\n      ctx.fillStyle = trial.canvas_colour;\n      ctx.fillRect(canvas_rect[0], canvas_rect[1], canvas_rect[2], canvas_rect[3]);\n      ctx.beginPath();\n    };\n\n    const display_word = (left_word: string, right_word: string) => {\n      clear_canvas();\n      ctx.font = sentence_font;\n      ctx.fillStyle = trial.font_colour;\n      ctx.fillText(left_word, position_left.x, position_left.y);\n      ctx.fillText(right_word, position_right.x, position_right.y);\n    };\n\n    const display_message = (message: string) => {\n      clear_canvas();\n      ctx.font = sentence_font;\n      ctx.fillStyle = trial.font_colour;\n      ctx.fillText(message, canvas_center.x, canvas_center.y);\n    };\n\n    const after_response = (info: { rt: number; key: string }) => {\n      if (undefined === last_display_time) {\n        last_display_time = 0;\n      }\n      const rt = info.rt - last_display_time;\n      if (rt < trial.waiting_time) {\n        return;\n      }\n      // FIXME: maybe we want to pre-allocate this stuff for more reactivity?\n      if (word_number >= 0) {\n        const correct = word_on_the_left[word_number]\n          ? info.key == trial.keys.left\n          : info.key == trial.keys.righ;\n        const [word, foil] = trial.sentence[word_number];\n        trial_data.events.push({\n          correct: correct,\n          foil: foil,\n          rt: rt,\n          side: word_on_the_left[word_number] ? \"left\" : \"right\",\n          word: word,\n          word_number: word_number,\n        });\n      }\n      if (word_number < trial.sentence.length - 1) {\n        word_number++;\n        const [word, foil] = trial.sentence[word_number];\n        const [left, right] = word_on_the_left[word_number] ? [word, foil] : [foil, word];\n        display_word(left, right);\n        last_display_time = info.rt;\n      } else {\n        end_trial();\n      }\n    };\n\n    const start_trial = () => {\n      word_number = -1;\n      word_on_the_left = Array.from(\n        { length: trial.sentence.length },\n        (_value, _index) => Math.random() < 0.5\n      );\n      display_message(`Press ${trial.keys.left} or ${trial.keys.right} to start`);\n      keyboardListener = this.jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: after_response,\n        valid_responses: [trial.keys.left, trial.keys.right],\n        rt_method: \"performance\",\n        persist: true,\n        allow_held_key: false,\n      });\n    };\n\n    const end_trial = () => {\n      this.jsPsych.pluginAPI.cancelKeyboardResponse(keyboardListener);\n      this.jsPsych.finishTrial(trial_data);\n    };\n\n    start_trial();\n  }\n}\n\nexport default MazePlugin;\n"],"names":[],"mappings":";;;EAEE,IAAW,OAAA,GAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICwHA,SAAA,EAAA;EAAA;;KAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}