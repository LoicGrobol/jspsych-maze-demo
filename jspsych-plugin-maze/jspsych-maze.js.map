{
    "version": 3,
    "file": "index.browser.min.js",
    "sources": [
        "../package.json",
        "../src/index.ts"
    ],
    "sourcesContent": [
        "{\n  \"name\": \"@jspsych-contrib/plugin-maze\",\n  \"version\": \"0.0.1\",\n  \"description\": \"A jsPsych plugin for running Maze experiments\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"typings\": \"dist/index.d.ts\",\n  \"unpkg\": \"dist/index.browser.min.js\",\n  \"files\": [\n    \"src\",\n    \"dist\"\n  ],\n  \"source\": \"src/index.ts\",\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"npm test -- --watch\",\n    \"tsc\": \"tsc\",\n    \"build\": \"rollup --config\",\n    \"build:watch\": \"npm run build -- --watch\",\n    \"dev-serve\": \"concurrently \\\"npm run build -- --watch\\\" \\\"serve\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jspsych/jspsych-contrib.git\",\n    \"directory\": \"packages/plugin-maze\"\n  },\n  \"author\": {\n    \"name\": \"Morgan Grobol\",\n    \"url\": \"https://lgrobol.bzh\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jspsych/jspsych-contrib/issues\"\n  },\n  \"homepage\": \"https://github.com/jspsych/jspsych-contrib/tree/main/packages/plugin-maze\",\n  \"peerDependencies\": {\n    \"jspsych\": \">=8.0.0\"\n  },\n  \"devDependencies\": {\n    \"@jspsych/config\": \"^3.2.2\",\n    \"@jspsych/test-utils\": \"^1.0.0\",\n    \"concurrently\": \"^9.1.2\",\n    \"jspsych\": \"^8.0.0\",\n    \"serve\": \"^14.2.4\"\n  }\n}\n",
        "import { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\nimport { KeyboardListener } from \"jspsych/dist/modules/plugin-api/KeyboardListenerAPI\";\n\nimport { version } from \"../package.json\";\n\nconst info = <const>{\n  name: \"maze\",\n  version: version,\n  parameters: {\n    /** Array of [word, foil] couples */\n    sentence: {\n      type: ParameterType.COMPLEX,\n      array: true,\n    },\n    /** Object with key \"text\", \"correct\", \"wrong\". Can't give a schema or it gets non-nullable. **/\n    question: {\n      type: ParameterType.COMPLEX,\n      default: null,\n    },\n    canvas_style: {\n      type: ParameterType.STRING,\n      pretty_name: \"Extra canvas style\",\n      default: \"border: 0px solid black;\",\n    },\n    canvas_colour: {\n      type: ParameterType.STRING,\n      pretty_name: \"Canvas colour\",\n      default: \"white\",\n    },\n    canvas_size: {\n      type: ParameterType.INT,\n      array: true,\n      pretty_name: \"Canvas size\",\n      default: [1280, 960],\n    },\n    font_colour: {\n      type: ParameterType.STRING,\n      pretty_name: \"Font colour\",\n      default: \"black\",\n    },\n    font_style: {\n      type: ParameterType.STRING,\n      pretty_name: \"Font size\",\n      default: \"normal 24px monospace\",\n    },\n    /** Whether to stop the trial on the first error and go directly to the question (if any) or\n     * exit. */\n    halt_on_error: {\n      type: ParameterType.BOOL,\n      pretty_name: \"Halt on error\",\n      default: false,\n    },\n    keys: {\n      type: ParameterType.COMPLEX,\n      pretty_name: \"Validation keys\",\n      default: { left: \"f\", right: \"j\" },\n      nested: {\n        left: {\n          type: ParameterType.STRING,\n          pretty_name: \"Left key\",\n        },\n        right: {\n          type: ParameterType.STRING,\n          pretty_name: \"Right key\",\n        },\n      },\n    },\n    position_left: {\n      type: ParameterType.COMPLEX,\n      pretty_name: \"Position of the left element.\",\n      default: { x: null, y: null },\n      nested: {\n        x: {\n          type: ParameterType.FLOAT,\n          pretty_name: \"Horizontal position\",\n        },\n      },\n      y: {\n        type: ParameterType.FLOAT,\n        pretty_name: \"Vertical position\",\n      },\n    },\n    position_right: {\n      type: ParameterType.COMPLEX,\n      pretty_name: \"Position of the right element \",\n      default: { x: null, y: null },\n      nested: {\n        x: {\n          type: ParameterType.FLOAT,\n          pretty_name: \"Horizontal position\",\n        },\n      },\n      y: {\n        type: ParameterType.FLOAT,\n        pretty_name: \"Vertical position\",\n      },\n    },\n    translate_origin: {\n      type: ParameterType.BOOL,\n      pretty_name: \"Translate origin\",\n      default: true,\n    },\n    /** How long to wait after showing a word and before registering keypresses (in ms) */\n    waiting_time: {\n      type: ParameterType.INT,\n      pretty_name: \"Waiting time\",\n      default: 0,\n    },\n  },\n  data: {\n    sentence: {\n      type: ParameterType.STRING,\n    },\n    events: {\n      type: ParameterType.COMPLEX,\n      array: true,\n      nested: {\n        correct: { type: ParameterType.BOOL },\n        foil: { type: ParameterType.STRING },\n        rt: { type: ParameterType.INT },\n        side: { type: ParameterType.STRING },\n        word: { type: ParameterType.STRING },\n        word_number: { type: ParameterType.INT },\n      },\n      question: {\n        type: ParameterType.COMPLEX,\n      },\n    },\n  },\n  // prettier-ignore\n  citations: '__CITATIONS__',\n};\n\ntype Info = typeof info;\n\nfunction set_canvas(\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  colour: string | CanvasGradient | CanvasPattern,\n  translate_origin: Boolean\n): [number, number, number, number] {\n  let canvas_rect: [number, number, number, number];\n  if (translate_origin) {\n    ctx.translate(canvas.width / 2, canvas.height / 2); // make center (0, 0)\n    canvas_rect = [-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height];\n  } else {\n    canvas_rect = [0, 0, canvas.width, canvas.height];\n  }\n  ctx.fillStyle = colour;\n  ctx.fillRect(canvas_rect[0], canvas_rect[1], canvas_rect[2], canvas_rect[3]);\n  ctx.beginPath();\n  return canvas_rect;\n}\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\n/**\n * **maze**\n *\n * A jsPsych plugin for running Maze experiments\n *\n * @author Morgan Grobol\n * @see {@link https://github.com/jspsych/jspsych-contrib/packages/plugin-maze/README.md}}\n */\nclass MazePlugin implements JsPsychPlugin<Info> {\n  static info = info;\n  display_element: HTMLElement;\n  canvas: HTMLCanvasElement;\n  canvas_colour: string;\n  canvas_rect: [number, number, number, number];\n  canvas_center: Position;\n  ctx: CanvasRenderingContext2D;\n  font_colour: string;\n  keyboard_listener: KeyboardListener;\n  keys: { left: string; right: string };\n  position_left: Position;\n  position_right: Position;\n  position_text: Position;\n\n  constructor(private jsPsych: JsPsych) {}\n\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\n    this.display_element = display_element;\n    this.display_element.innerHTML = `<div>\n      <canvas\n        id=\"canvas\"\n        width=\"${trial.canvas_size[0]}\"\n        height=\"${trial.canvas_size[1]}\"\n        style=\"${trial.canvas_style}\"\n      ></canvas>\n      </div>`;\n\n    this.canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n    this.canvas_colour = trial.canvas_colour;\n\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.ctx.font = trial.font_style;\n    this.ctx.textAlign = \"center\";\n    this.ctx.textBaseline = \"middle\";\n\n    this.canvas_rect = set_canvas(\n      this.canvas,\n      this.ctx,\n      this.canvas_colour,\n      trial.translate_origin\n    );\n    this.canvas_center = {\n      x: this.canvas_rect[0] + this.canvas_rect[2] / 2,\n      y: this.canvas_rect[1] + this.canvas_rect[3] / 2,\n    };\n\n    this.font_colour = trial.font_colour;\n    this.keys = trial.keys;\n\n    this.position_left = {\n      x:\n        trial.position_left.x !== null\n          ? trial.position_left.x\n          : this.canvas_rect[0] + this.canvas_rect[2] / 3,\n      y: trial.position_left.y !== null ? trial.position_left.y : this.canvas_center.y,\n    };\n    this.position_right = {\n      x:\n        trial.position_right.x !== null\n          ? trial.position_right.x\n          : this.canvas_rect[0] + (2 * this.canvas_rect[2]) / 3,\n      y: trial.position_right.y !== null ? trial.position_right.y : this.canvas_center.y,\n    };\n    this.position_text = {\n      x: this.canvas_center.x,\n      y: (this.canvas_center.y + this.canvas_rect[1]) / 2,\n    };\n\n    const results: {\n      sentence: string;\n      events: Array<{\n        correct: boolean;\n        foil: string;\n        rt: number;\n        side: \"left\" | \"right\";\n        word: string;\n      }>;\n      question: {\n        question: { text: string; correct: string; wrong: string };\n        correct: boolean;\n        rt: number;\n      } | null;\n    } = {\n      sentence: trial.sentence.map((x) => x[0]).join(\" \"),\n      events: [],\n      question: null,\n    };\n\n    let last_display_time: number;\n    let word_number = 0;\n    const word_on_the_left = Array.from(\n      { length: trial.sentence.length },\n      (_value, _index) => Math.random() < 0.5\n    );\n\n    const ask_question = () => {\n      this.jsPsych.pluginAPI.cancelKeyboardResponse(this.keyboard_listener);\n      const correct_on_the_left = Math.random() < 0.5;\n      const [left, right] = correct_on_the_left\n        ? [trial.question.correct, trial.question.wrong]\n        : [trial.question.wrong, trial.question.correct];\n      this.display_words(left, right, trial.question.text);\n      this.keyboard_listener = this.jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: (info: { rt: number; key: string }) => {\n          results.question = {\n            question: trial.question,\n            correct: correct_on_the_left ? info.key == this.keys.left : info.key == this.keys.right,\n            rt: info.rt,\n          };\n          end_trial();\n        },\n        valid_responses: [this.keys.left, this.keys.right],\n        rt_method: \"performance\",\n        persist: true,\n        allow_held_key: false,\n      });\n    };\n\n    const step_display = (n: number) => {\n      const [word, foil] = trial.sentence[n];\n      const [left, right] = word_on_the_left[n] ? [word, foil] : [foil, word];\n      this.display_words(left, right);\n    };\n\n    const after_response = (info: { rt: number; key: string }) => {\n      const rt = info.rt - last_display_time;\n      const correct = word_on_the_left[word_number]\n        ? info.key == this.keys.left\n        : info.key == this.keys.right;\n      const [word, foil] = trial.sentence[word_number];\n      // FIXME: maybe we want to pre-allocate trial_data.events for more reactivity?\n      results.events.push({\n        correct: correct,\n        foil: foil,\n        rt: rt,\n        side: word_on_the_left[word_number] ? \"left\" : \"right\",\n        word: word,\n      });\n      if (word_number < trial.sentence.length - 1 && (correct || !trial.halt_on_error)) {\n        word_number++;\n        step_display(word_number);\n        last_display_time = info.rt;\n      } else {\n        if (undefined !== trial.question) {\n          ask_question();\n        } else {\n          end_trial();\n        }\n      }\n    };\n\n    const start_trial = (info: { rt: number; key: string }) => {\n      step_display(0);\n      last_display_time = info.rt;\n      this.keyboard_listener = this.jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: after_response,\n        valid_responses: [this.keys.left, this.keys.right],\n        rt_method: \"performance\",\n        persist: true,\n        allow_held_key: false,\n        minimum_valid_rt: trial.waiting_time,\n      });\n    };\n\n    const end_trial = () => {\n      this.jsPsych.pluginAPI.cancelKeyboardResponse(this.keyboard_listener);\n      this.jsPsych.finishTrial(results);\n    };\n\n    const setup = () => {\n      this.display_message(`Press ${this.keys.left} or ${this.keys.right} to start`);\n      this.keyboard_listener = this.jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: start_trial,\n        valid_responses: [this.keys.left, this.keys.right],\n        persist: false,\n        allow_held_key: false,\n      });\n    };\n\n    setup();\n  }\n\n  clear_canvas() {\n    this.ctx.fillStyle = this.canvas_colour;\n    this.ctx.fillRect(...this.canvas_rect);\n    this.ctx.beginPath();\n  }\n\n  display_words(left_word: string, right_word: string, text: string = null) {\n    this.clear_canvas();\n    this.ctx.fillStyle = this.font_colour;\n    this.ctx.fillText(left_word, this.position_left.x, this.position_left.y);\n    this.ctx.fillText(right_word, this.position_right.x, this.position_right.y);\n    if (null !== text) {\n      this.ctx.fillText(text, this.position_text.x, this.position_text.y);\n    }\n  }\n\n  display_message(message: string) {\n    this.clear_canvas();\n    this.ctx.fillStyle = this.font_colour;\n    this.ctx.fillText(message, this.canvas_center.x, this.canvas_center.y);\n  }\n}\n\nexport default MazePlugin;\n"
    ],
    "names": [
        "version"
    ],
    "mappings": "yCAEEA,IAAAA,EAAW,45DCgIA,UAAA,iBAAe;;;;;;;"
}