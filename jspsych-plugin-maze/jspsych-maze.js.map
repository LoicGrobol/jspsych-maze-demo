{"version":3,"file":"jspsych-maze.browser.js","sources":["../package.json","../src/index.ts"],"sourcesContent":["{\n  \"name\": \"@jspsych-contrib/plugin-maze\",\n  \"version\": \"0.0.1\",\n  \"description\": \"A jsPsych plugin for running Maze experiments\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"typings\": \"dist/index.d.ts\",\n  \"unpkg\": \"dist/index.browser.min.js\",\n  \"files\": [\n    \"src\",\n    \"dist\"\n  ],\n  \"source\": \"src/index.ts\",\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"npm test -- --watch\",\n    \"tsc\": \"tsc\",\n    \"build\": \"rollup --config\",\n    \"build:watch\": \"npm run build -- --watch\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jspsych/jspsych-contrib.git\",\n    \"directory\": \"packages/plugin-maze\"\n  },\n  \"author\": {\n    \"name\": \"Morgan Grobol\",\n    \"url\": \"https://lgrobol.bzh\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jspsych/jspsych-contrib/issues\"\n  },\n  \"homepage\": \"https://github.com/jspsych/jspsych-contrib/tree/main/packages/plugin-maze\",\n  \"peerDependencies\": {\n    \"jspsych\": \">=8.0.0\"\n  },\n  \"devDependencies\": {\n    \"@jspsych/config\": \"^3.2.2\",\n    \"@jspsych/test-utils\": \"^1.0.0\",\n    \"jspsych\": \"^8.0.0\"\n  }\n}\n","import { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\n\nimport { version } from \"../package.json\";\n\nconst info = <const>{\n  name: \"maze\",\n  version: version,\n  parameters: {\n    /** Array of [word, foil] couples */\n    sentence: {\n      type: ParameterType.COMPLEX,\n      array: true,\n    },\n    canvas_size: {\n      type: ParameterType.STRING,\n      array: true,\n      pretty_name: \"Canvas size\",\n      default: [\"1280px\", \"960px\"],\n    },\n\n    /** Whether to stop the trial on the first error.*/\n    halt_on_error: {\n      type: ParameterType.BOOL,\n      pretty_name: \"Halt on error\",\n      default: false,\n    },\n    /** How long to wait on a blank screen before displaying the next word. */\n    inter_word_interval: {\n      type: ParameterType.INT,\n      pretty_name: \"Inter-words interval\",\n      default: 0,\n    },\n    keys: {\n      type: ParameterType.COMPLEX,\n      pretty_name: \"Validation keys\",\n      default: { left: \"f\", right: \"j\" },\n      nested: {\n        left: {\n          type: ParameterType.STRING,\n          pretty_name: \"Left key\",\n        },\n        right: {\n          type: ParameterType.STRING,\n          pretty_name: \"Right key\",\n        },\n      },\n    },\n    /** The minimum time (in ms) before the subject is allowed to chose a word. */\n    pre_answer_interval: {\n      type: ParameterType.INT,\n      pretty_name: \"Pre-answer Interval\",\n      default: 0,\n    },\n  },\n  data: {\n    sentence: {\n      type: ParameterType.STRING,\n    },\n    events: {\n      type: ParameterType.COMPLEX,\n      array: true,\n      nested: {\n        correct: { type: ParameterType.BOOL },\n        foil: { type: ParameterType.STRING },\n        rt: { type: ParameterType.INT },\n        side: { type: ParameterType.STRING },\n        word: { type: ParameterType.STRING },\n        word_number: { type: ParameterType.INT },\n      },\n    },\n  },\n  // prettier-ignore\n  citations: '__CITATIONS__',\n};\n\ntype Info = typeof info;\n\ninterface Response {\n  correct: boolean;\n  foil: string;\n  rt: number;\n  side: \"left\" | \"right\";\n  word: string;\n}\n\n/**\n * **maze**\n *\n * A jsPsych plugin for running Maze experiments\n *\n * @author Morgan Grobol\n * @see {@link https://github.com/jspsych/jspsych-contrib/packages/plugin-maze/README.md}}\n */\nclass MazePlugin implements JsPsychPlugin<Info> {\n  static info = info;\n  display_element: HTMLElement;\n  canvas_colour: string;\n  center_clientX: number;\n  center_display: HTMLElement;\n  display_parent: HTMLElement;\n  keys: { left: string; right: string };\n  left_display: HTMLElement;\n  right_display: HTMLElement;\n  style: HTMLElement;\n  text_display: HTMLElement;\n\n  constructor(private jsPsych: JsPsych) {}\n\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\n    this.display_element = display_element;\n    this.display_element.innerHTML = `\n      <div id=\"jspsych-maze-display_parent\">\n        <div id=\"jspsych-maze-center_display\" class=\"jspsych-maze-display\"></div>\n        <div id=\"jspsych-maze-text_display\" class=\"jspsych-maze-display\"></div>\n        <div id=\"jspsych-maze-left_display\" class=\"jspsych-maze-display jspsy-maze-answer\"></div>\n        <div id=\"jspsych-maze-right_display\" class=\"jspsych-maze-display jspsy-maze-answer\"></div>\n      </div>`;\n    this.style = document.createElement(\"style\");\n    this.style.innerHTML = `\n\t\thtml, body { overscroll-behavior-y: contain; }\n\t\t#jspsych-maze-display_parent {\n\t\t\tposition: relative;\n\t\t\twidth: ${trial.canvas_size[0]};\n\t\t\theight: ${trial.canvas_size[1]};\n\t\t}\n\t\t.jspsych-maze-display{\n\t\t\tposition: absolute;\n\t\t}\n\t\t.jspsych-maze-answer{\n\t\t\twidth: max-content;\n\t\t}\n\t\t.highlighted {\n\t\t\tborder: 2px solid red;\n\t\t}\n\t\t#jspsych-maze-center_display {\n\t\t\ttop: 50%;\n\t\t\ttransform: translateY(-50%);\n\t\t\twidth: 100%;\n\t\t}\n\t\t#jspsych-maze-text_display {\n\t\t\ttop: 50%;\n\t\t\ttransform: translateY(-50%) translateY(-5em);\n\t\t\twidth: 100%;\n\t\t}\n\t\t#jspsych-maze-left_display {\n\t\t\tleft: calc(100% / 3);\n\t\t\ttop: 50%;\n\t\t\ttransform: translate(-50%, -50%);\n\t\t}\n\t\t#jspsych-maze-right_display {\n\t\t\tleft: calc(2 * (100% / 3));\n\t\t\ttop: 50%;\n\t\t\ttransform: translate(-50%, -50%);\n\t\t}\n      `;\n    document.head.appendChild(this.style);\n    this.display_parent = document.getElementById(\"jspsych-maze-display_parent\");\n    this.center_clientX = this.display_element.clientLeft + 0.5 * this.display_element.clientWidth;\n    this.center_display = document.getElementById(\"jspsych-maze-center_display\");\n    this.left_display = document.getElementById(\"jspsych-maze-left_display\");\n    this.right_display = document.getElementById(\"jspsych-maze-right_display\");\n    this.text_display = document.getElementById(\"jspsych-maze-text_display\");\n\n    this.keys = trial.keys;\n\n    const results: {\n      sentence: string;\n      events: Array<Response>;\n    } = {\n      sentence: trial.sentence.map((x) => x[0]).join(\" \"),\n      events: [],\n    };\n\n    const word_on_the_left = Array.from(\n      { length: trial.sentence.length },\n      (_value, _index) => Math.random() < 0.5\n    );\n\n    const listen_input = (callback: (response_is_left: boolean) => void) => {\n      const cancelers: Array<() => void> = [];\n      const next = (input_type: string, response_is_left: boolean) => {\n        for (const handle of cancelers) {\n          handle();\n        }\n        callback(response_is_left);\n      };\n\n      // NOTE: could do it with native events but this has the benefit of having just one true\n      // listener at all time (see implementation of getKeyBoardResponse)\n      const keyboard_listener = this.jsPsych.pluginAPI.getKeyboardResponse({\n        callback_function: (info: { key: string; rt: number }) => {\n          next(\"keyboard\", this.jsPsych.pluginAPI.compareKeys(info.key, this.keys.left));\n        },\n        valid_responses: [this.keys.left, this.keys.right],\n        rt_method: \"performance\",\n        allow_held_key: false,\n      });\n      cancelers.push(() => this.jsPsych.pluginAPI.cancelKeyboardResponse(keyboard_listener));\n\n      const swipe_listener = listen_to_swipe(\n        this.jsPsych.getDisplayContainerElement(),\n        (response_is_left) => {\n          this.left_display.classList.remove(\"highlighted\");\n          this.right_display.classList.remove(\"highlighted\");\n          next(\"touch\", response_is_left);\n        },\n        {\n          move_callback: (start_touch: Touch, current_touch: Touch) => {\n            if (current_touch.pageX < start_touch.pageX) {\n              this.left_display.classList.add(\"highlighted\");\n              this.right_display.classList.remove(\"highlighted\");\n            } else {\n              this.left_display.classList.remove(\"highlighted\");\n              this.right_display.classList.add(\"highlighted\");\n            }\n          },\n        }\n      );\n      cancelers.push(swipe_listener);\n    };\n\n    const start_step = (word_number: number) => {\n      const [word, foil] = trial.sentence[word_number];\n      const [left, right] = word_on_the_left[word_number] ? [word, foil] : [foil, word];\n      this.display_words(left, right);\n      const last_display_time = performance.now();\n      // TODO: I would like to await sleep() here but I haven't figured out how to make jest work\n      // with that yet\n      this.jsPsych.pluginAPI.setTimeout(\n        () =>\n          listen_input((response_is_left: boolean) => {\n            process_response(performance.now() - last_display_time, word_number, response_is_left);\n          }),\n        trial.pre_answer_interval\n      );\n    };\n\n    const process_response = (interval: number, word_number: number, response_is_left: boolean) => {\n      const correct = word_on_the_left[word_number] === response_is_left;\n      const [word, foil] = trial.sentence[word_number];\n      // FIXME: maybe we want to pre-allocate trial_data.events for more reactivity?\n      results.events.push({\n        correct: correct,\n        foil: foil,\n        rt: interval,\n        side: word_on_the_left[word_number] ? \"left\" : \"right\",\n        word: word,\n      } as Response);\n      if (word_number < trial.sentence.length - 1 && (correct || !trial.halt_on_error)) {\n        this.clear_display();\n        this.jsPsych.pluginAPI.setTimeout(\n          () => start_step(word_number + 1),\n          trial.inter_word_interval\n        );\n      } else {\n        end_trial();\n      }\n    };\n\n    const start_trial = () => {\n      start_step(0);\n    };\n\n    const end_trial = () => {\n      this.jsPsych.finishTrial(results);\n    };\n\n    const setup = () => {\n      this.display_message(`Press ${this.keys.left} or ${this.keys.right} to start`);\n      listen_input((response_is_left) => start_trial());\n    };\n\n    setup();\n  }\n\n  clear_display() {\n    this.center_display.innerHTML = \"\";\n    this.left_display.innerHTML = \"\";\n    this.right_display.innerHTML = \"\";\n    this.text_display.innerHTML = \"\";\n  }\n\n  display_words(left_word: string, right_word: string, text: string | null = null) {\n    this.clear_display();\n\n    this.left_display.innerHTML = left_word;\n    this.right_display.innerHTML = right_word;\n\n    if (null !== text) {\n      this.text_display.innerHTML = text;\n    }\n  }\n\n  display_message(message: string) {\n    this.clear_display();\n    this.center_display.innerHTML = message;\n  }\n}\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction listen_to_swipe(\n  element: HTMLElement,\n  callback: (response_is_left: boolean) => void,\n  options: {\n    touch_callback?: (touch: Touch) => void;\n    move_callback?: (start_touch: Touch, current_touch: Touch) => void;\n    min_distance?: number;\n  } = {}\n) {\n  const min_distance = options.min_distance ?? 0;\n  const touch_controller = new AbortController();\n  const ongoingTouches = new Map<number, Touch>();\n  element.addEventListener(\n    \"touchstart\",\n    (e) => {\n      e.preventDefault();\n      for (const touch of e.changedTouches) {\n        ongoingTouches.set(touch.identifier, touch);\n        if (options.touch_callback) {\n          options.touch_callback(touch);\n        }\n      }\n    },\n    { signal: touch_controller.signal }\n  );\n\n  if (options.move_callback) {\n    element.addEventListener(\n      \"touchmove\",\n      (e) => {\n        e.preventDefault();\n        for (const current_touch of e.changedTouches) {\n          const start_touch = ongoingTouches.get(current_touch.identifier);\n          options.move_callback(start_touch, current_touch);\n        }\n      },\n      { signal: touch_controller.signal }\n    );\n  }\n\n  element.addEventListener(\n    \"touchcancel\",\n    (e) => {\n      e.preventDefault();\n      for (const touch of e.changedTouches) {\n        ongoingTouches.delete(touch.identifier);\n      }\n    },\n    { signal: touch_controller.signal }\n  );\n\n  element.addEventListener(\n    \"touchend\",\n    (e) => {\n      e.preventDefault();\n      for (const end_touch of e.changedTouches) {\n        const start_touch = ongoingTouches.get(end_touch.identifier);\n        if (end_touch.pageX < start_touch.pageX - min_distance) {\n          callback(true);\n        } else if (end_touch.pageX > start_touch.pageX + min_distance) {\n          callback(false);\n        }\n      }\n    },\n    { signal: touch_controller.signal }\n  );\n  return () => touch_controller.abort();\n}\n\nexport default MazePlugin;\n"],"names":[],"mappings":";;;EAEE,IAAW,OAAA,GAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICsEA,SAAA,EAAA;EAAA;;KAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}